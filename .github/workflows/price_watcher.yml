name: Weekly Walmart Price Update
on:
  schedule:
    - cron: '0 0 * * 0' # Every Sunday at Midnight UTC
  workflow_dispatch:

jobs:
  update-prices:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Tools
        run: pip install requests supabase

      - name: Run Walmart Scraper
        env:
          SERPAPI_KEY: ${{ secrets.SERPAPI_KEY }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          python - <<EOF
          import os
          import requests
          from supabase import create_client

          supabase = create_client(os.getenv("SUPABASE_URL"), os.getenv("SUPABASE_KEY"))
          
          # 1. Fetch watched items
          items = supabase.table("prices").select("*").eq("is_watched", True).execute().data
          print(f"Checking {len(items)} watched items for T6X 1X2 area...")

          for item in items:
              try:
                  url = item.get('external_url', '')
                  if not url or 'walmart.ca' not in url:
                      continue

                  product_id = url.split('?')[0].rstrip('/').split('/')[-1]
                  store_id = item.get('store_id') or "1187" # Your nearest Walmart
                  postal_code = "T6X1X2" 
                  
                  # STRATEGY: Name + Brand + Postal Code Search
                  # This mimics a human searching locally, which surfaces inventory effectively
                  search_query = f"{item.get('brand', '')} {item['item_name']} {postal_code}".strip()
                  print(f"\nüîç LOCAL SEARCH: '{search_query}' (Store: {store_id})")

                  params = {
                      "engine": "walmart",
                      "query": search_query,
                      "walmart_domain": "walmart.ca",
                      "store_id": store_id,
                      "api_key": os.getenv("SERPAPI_KEY")
                  }
                  
                  r = requests.get("https://serpapi.com/search", params=params)
                  data = r.json()
                  
                  new_price = None
                  results = data.get('organic_results', [])

                  # Verification: Look for the result that matches your Product ID in the URL
                  for res in results:
                      if product_id in res.get('link', ''):
                          new_price = res.get('primary_offer', {}).get('price') or res.get('price')
                          if new_price:
                              print(f"   ‚úÖ Local match found: {res.get('title')} -> ${new_price}")
                              break

                  # FALLBACK: If name search didn't work, try ID + Postal Code
                  if not new_price:
                      print(f"   ‚ö†Ô∏è Name search failed. Trying ID + Postal Code...")
                      params['query'] = f"{product_id} {postal_code}"
                      r = requests.get("https://serpapi.com/search", params=params)
                      data = r.json()
                      organic = data.get('organic_results', [])
                      if organic:
                          new_price = organic[0].get('primary_offer', {}).get('price') or organic[0].get('price')

                  # SAVE TO DATABASE
                  if new_price:
                      final_price = float(str(new_price).replace('$', '').replace(',', ''))
                      supabase.table("prices").update({
                          "price": final_price,
                          "last_automated_update": "now()"
                      }).eq("id", item['id']).execute()
                      print(f"‚úÖ SUCCESS: {item['item_name']} updated to ${final_price}")
                  else:
                      print(f"‚ùå FAILED: Item not found. Walmart may have it out of stock at store {store_id}.")

              except Exception as e:
                  print(f"‚ö†Ô∏è ERROR: {str(e)}")
          EOF
