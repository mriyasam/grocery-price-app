name: Weekly Walmart Price Update
on:
  schedule:
    - cron: '0 0 * * 0' # Every Sunday at Midnight UTC
  workflow_dispatch: # Allows you to click a button to run it manually

jobs:
  update-prices:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Tools
        run: pip install requests supabase

      - name: Run Walmart Scraper
        env:
          SERPAPI_KEY: ${{ secrets.SERPAPI_KEY }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          python - <<EOF
          import os
          import requests
          from supabase import create_client

          supabase = create_client(os.getenv("SUPABASE_URL"), os.getenv("SUPABASE_KEY"))
          
          items = supabase.table("prices").select("*").eq("is_watched", True).execute().data
          print(f"Found {len(items)} items to update.")

          for item in items:
              try:
                  url = item.get('external_url', '')
                  if not url or 'walmart.ca' not in url:
                      continue

                  # Clean URL and extract ID
                  clean_url = url.split('?')[0].rstrip('/')
                  product_id = clean_url.split('/')[-1]
                  store_id = item.get('store_id') or "3106"
                  
                  print(f"--- Processing: {item['item_name']} (ID: {product_id}) ---")

                  # LAYER 1: Try direct Product Engine WITH Store ID
                  params = {
                      "engine": "walmart_product",
                      "product_id": product_id,
                      "walmart_domain": "walmart.ca",
                      "store_id": store_id,
                      "api_key": os.getenv("SERPAPI_KEY")
                  }
                  
                  data = requests.get("https://serpapi.com/search", params=params).json()
                  
                  # LAYER 2: If not found, try WITHOUT Store ID (National Price)
                  if "error" in data and "could not be found" in data["error"].lower():
                      print(f"⚠️ Not found at store {store_id}. Retrying without store filter...")
                      params.pop("store_id")
                      data = requests.get("https://serpapi.com/search", params=params).json()

                  # LAYER 3: If still not found, use the Search Engine as a fallback
                  if "error" in data and "could not be found" in data["error"].lower():
                      print(f"⚠️ Direct page failed. Retrying via Walmart Search Engine...")
                      search_params = {
                          "engine": "walmart",
                          "query": product_id, # Searching by ID is very accurate
                          "walmart_domain": "walmart.ca",
                          "api_key": os.getenv("SERPAPI_KEY")
                      }
                      search_data = requests.get("https://serpapi.com/search", params=search_params).json()
                      # Grab the first search result's price
                      organic = search_data.get('organic_results', [])
                      if organic:
                          product_result = organic[0]
                      else:
                          product_result = {}
                  else:
                      product_result = data.get('product_result', {})

                  # EXTRACTION LOGIC
                  new_price = product_result.get('price') or product_result.get('primary_offer', {}).get('price')
                  
                  if not new_price and 'buying_options' in product_result:
                      new_price = product_result['buying_options'][0].get('price')

                  if new_price:
                      final_price = float(str(new_price).replace('$', '').replace(',', ''))
                      supabase.table("prices").update({
                          "price": final_price,
                          "last_automated_update": "now()"
                      }).eq("id", item['id']).execute()
                      print(f"✅ SUCCESS: {item['item_name']} updated to ${final_price}")
                  else:
                      print(f"❌ FAILED: Price still not found for {item['item_name']}.")

              except Exception as e:
                  print(f"⚠️ SYSTEM ERROR: {str(e)}")
          EOF
